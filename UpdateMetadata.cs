// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: update_metadata.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace ChromeosUpdateEngine {

  /// <summary>Holder for reflection information generated from update_metadata.proto</summary>
  public static partial class UpdateMetadataReflection {

    #region Descriptor
    /// <summary>File descriptor for update_metadata.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static UpdateMetadataReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChV1cGRhdGVfbWV0YWRhdGEucHJvdG8SFmNocm9tZW9zX3VwZGF0ZV9lbmdp",
            "bmUiMQoGRXh0ZW50EhMKC3N0YXJ0X2Jsb2NrGAEgASgEEhIKCm51bV9ibG9j",
            "a3MYAiABKAQinwEKClNpZ25hdHVyZXMSQAoKc2lnbmF0dXJlcxgBIAMoCzIs",
            "LmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuU2lnbmF0dXJlcy5TaWduYXR1cmUa",
            "TwoJU2lnbmF0dXJlEhMKB3ZlcnNpb24YASABKA1CAhgBEgwKBGRhdGEYAiAB",
            "KAwSHwoXdW5wYWRkZWRfc2lnbmF0dXJlX3NpemUYAyABKAciKwoNUGFydGl0",
            "aW9uSW5mbxIMCgRzaXplGAEgASgEEgwKBGhhc2gYAiABKAwidwoJSW1hZ2VJ",
            "bmZvEg0KBWJvYXJkGAEgASgJEgsKA2tleRgCIAEoCRIPCgdjaGFubmVsGAMg",
            "ASgJEg8KB3ZlcnNpb24YBCABKAkSFQoNYnVpbGRfY2hhbm5lbBgFIAEoCRIV",
            "Cg1idWlsZF92ZXJzaW9uGAYgASgJIu4DChBJbnN0YWxsT3BlcmF0aW9uEjsK",
            "BHR5cGUYASACKA4yLS5jaHJvbWVvc191cGRhdGVfZW5naW5lLkluc3RhbGxP",
            "cGVyYXRpb24uVHlwZRITCgtkYXRhX29mZnNldBgCIAEoBBITCgtkYXRhX2xl",
            "bmd0aBgDIAEoBBIzCgtzcmNfZXh0ZW50cxgEIAMoCzIeLmNocm9tZW9zX3Vw",
            "ZGF0ZV9lbmdpbmUuRXh0ZW50EhIKCnNyY19sZW5ndGgYBSABKAQSMwoLZHN0",
            "X2V4dGVudHMYBiADKAsyHi5jaHJvbWVvc191cGRhdGVfZW5naW5lLkV4dGVu",
            "dBISCgpkc3RfbGVuZ3RoGAcgASgEEhgKEGRhdGFfc2hhMjU2X2hhc2gYCCAB",
            "KAwSFwoPc3JjX3NoYTI1Nl9oYXNoGAkgASgMIq0BCgRUeXBlEgsKB1JFUExB",
            "Q0UQABIOCgpSRVBMQUNFX0JaEAESDAoETU9WRRACGgIIARIOCgZCU0RJRkYQ",
            "AxoCCAESDwoLU09VUkNFX0NPUFkQBBIRCg1TT1VSQ0VfQlNESUZGEAUSDgoK",
            "UkVQTEFDRV9YWhAIEggKBFpFUk8QBhILCgdESVNDQVJEEAcSEQoNQlJPVExJ",
            "X0JTRElGRhAKEgwKCFBVRkZESUZGEAki1wUKD1BhcnRpdGlvblVwZGF0ZRIW",
            "Cg5wYXJ0aXRpb25fbmFtZRgBIAIoCRIXCg9ydW5fcG9zdGluc3RhbGwYAiAB",
            "KAgSGAoQcG9zdGluc3RhbGxfcGF0aBgDIAEoCRIXCg9maWxlc3lzdGVtX3R5",
            "cGUYBCABKAkSTQoXbmV3X3BhcnRpdGlvbl9zaWduYXR1cmUYBSADKAsyLC5j",
            "aHJvbWVvc191cGRhdGVfZW5naW5lLlNpZ25hdHVyZXMuU2lnbmF0dXJlEkEK",
            "Em9sZF9wYXJ0aXRpb25faW5mbxgGIAEoCzIlLmNocm9tZW9zX3VwZGF0ZV9l",
            "bmdpbmUuUGFydGl0aW9uSW5mbxJBChJuZXdfcGFydGl0aW9uX2luZm8YByAB",
            "KAsyJS5jaHJvbWVvc191cGRhdGVfZW5naW5lLlBhcnRpdGlvbkluZm8SPAoK",
            "b3BlcmF0aW9ucxgIIAMoCzIoLmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuSW5z",
            "dGFsbE9wZXJhdGlvbhIcChRwb3N0aW5zdGFsbF9vcHRpb25hbBgJIAEoCBI9",
            "ChVoYXNoX3RyZWVfZGF0YV9leHRlbnQYCiABKAsyHi5jaHJvbWVvc191cGRh",
            "dGVfZW5naW5lLkV4dGVudBI4ChBoYXNoX3RyZWVfZXh0ZW50GAsgASgLMh4u",
            "Y2hyb21lb3NfdXBkYXRlX2VuZ2luZS5FeHRlbnQSGwoTaGFzaF90cmVlX2Fs",
            "Z29yaXRobRgMIAEoCRIWCg5oYXNoX3RyZWVfc2FsdBgNIAEoDBI3Cg9mZWNf",
            "ZGF0YV9leHRlbnQYDiABKAsyHi5jaHJvbWVvc191cGRhdGVfZW5naW5lLkV4",
            "dGVudBIyCgpmZWNfZXh0ZW50GA8gASgLMh4uY2hyb21lb3NfdXBkYXRlX2Vu",
            "Z2luZS5FeHRlbnQSFAoJZmVjX3Jvb3RzGBAgASgNOgEyIkwKFUR5bmFtaWNQ",
            "YXJ0aXRpb25Hcm91cBIMCgRuYW1lGAEgAigJEgwKBHNpemUYAiABKAQSFwoP",
            "cGFydGl0aW9uX25hbWVzGAMgAygJInMKGER5bmFtaWNQYXJ0aXRpb25NZXRh",
            "ZGF0YRI9CgZncm91cHMYASADKAsyLS5jaHJvbWVvc191cGRhdGVfZW5naW5l",
            "LkR5bmFtaWNQYXJ0aXRpb25Hcm91cBIYChBzbmFwc2hvdF9lbmFibGVkGAIg",
            "ASgIIrEGChREZWx0YUFyY2hpdmVNYW5pZmVzdBJEChJpbnN0YWxsX29wZXJh",
            "dGlvbnMYASADKAsyKC5jaHJvbWVvc191cGRhdGVfZW5naW5lLkluc3RhbGxP",
            "cGVyYXRpb24SSwoZa2VybmVsX2luc3RhbGxfb3BlcmF0aW9ucxgCIAMoCzIo",
            "LmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuSW5zdGFsbE9wZXJhdGlvbhIYCgpi",
            "bG9ja19zaXplGAMgASgNOgQ0MDk2EhkKEXNpZ25hdHVyZXNfb2Zmc2V0GAQg",
            "ASgEEhcKD3NpZ25hdHVyZXNfc2l6ZRgFIAEoBBI+Cg9vbGRfa2VybmVsX2lu",
            "Zm8YBiABKAsyJS5jaHJvbWVvc191cGRhdGVfZW5naW5lLlBhcnRpdGlvbklu",
            "Zm8SPgoPbmV3X2tlcm5lbF9pbmZvGAcgASgLMiUuY2hyb21lb3NfdXBkYXRl",
            "X2VuZ2luZS5QYXJ0aXRpb25JbmZvEj4KD29sZF9yb290ZnNfaW5mbxgIIAEo",
            "CzIlLmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuUGFydGl0aW9uSW5mbxI+Cg9u",
            "ZXdfcm9vdGZzX2luZm8YCSABKAsyJS5jaHJvbWVvc191cGRhdGVfZW5naW5l",
            "LlBhcnRpdGlvbkluZm8SOQoOb2xkX2ltYWdlX2luZm8YCiABKAsyIS5jaHJv",
            "bWVvc191cGRhdGVfZW5naW5lLkltYWdlSW5mbxI5Cg5uZXdfaW1hZ2VfaW5m",
            "bxgLIAEoCzIhLmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuSW1hZ2VJbmZvEhgK",
            "DW1pbm9yX3ZlcnNpb24YDCABKA06ATASOwoKcGFydGl0aW9ucxgNIAMoCzIn",
            "LmNocm9tZW9zX3VwZGF0ZV9lbmdpbmUuUGFydGl0aW9uVXBkYXRlEhUKDW1h",
            "eF90aW1lc3RhbXAYDiABKAMSVAoaZHluYW1pY19wYXJ0aXRpb25fbWV0YWRh",
            "dGEYDyABKAsyMC5jaHJvbWVvc191cGRhdGVfZW5naW5lLkR5bmFtaWNQYXJ0",
            "aXRpb25NZXRhZGF0YUICSAM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.Extent), global::ChromeosUpdateEngine.Extent.Parser, new[]{ "StartBlock", "NumBlocks" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.Signatures), global::ChromeosUpdateEngine.Signatures.Parser, new[]{ "Signatures_" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.Signatures.Types.Signature), global::ChromeosUpdateEngine.Signatures.Types.Signature.Parser, new[]{ "Version", "Data", "UnpaddedSignatureSize" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.PartitionInfo), global::ChromeosUpdateEngine.PartitionInfo.Parser, new[]{ "Size", "Hash" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.ImageInfo), global::ChromeosUpdateEngine.ImageInfo.Parser, new[]{ "Board", "Key", "Channel", "Version", "BuildChannel", "BuildVersion" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.InstallOperation), global::ChromeosUpdateEngine.InstallOperation.Parser, new[]{ "Type", "DataOffset", "DataLength", "SrcExtents", "SrcLength", "DstExtents", "DstLength", "DataSha256Hash", "SrcSha256Hash" }, null, new[]{ typeof(global::ChromeosUpdateEngine.InstallOperation.Types.Type) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.PartitionUpdate), global::ChromeosUpdateEngine.PartitionUpdate.Parser, new[]{ "PartitionName", "RunPostinstall", "PostinstallPath", "FilesystemType", "NewPartitionSignature", "OldPartitionInfo", "NewPartitionInfo", "Operations", "PostinstallOptional", "HashTreeDataExtent", "HashTreeExtent", "HashTreeAlgorithm", "HashTreeSalt", "FecDataExtent", "FecExtent", "FecRoots" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.DynamicPartitionGroup), global::ChromeosUpdateEngine.DynamicPartitionGroup.Parser, new[]{ "Name", "Size", "PartitionNames" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.DynamicPartitionMetadata), global::ChromeosUpdateEngine.DynamicPartitionMetadata.Parser, new[]{ "Groups", "SnapshotEnabled" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::ChromeosUpdateEngine.DeltaArchiveManifest), global::ChromeosUpdateEngine.DeltaArchiveManifest.Parser, new[]{ "InstallOperations", "KernelInstallOperations", "BlockSize", "SignaturesOffset", "SignaturesSize", "OldKernelInfo", "NewKernelInfo", "OldRootfsInfo", "NewRootfsInfo", "OldImageInfo", "NewImageInfo", "MinorVersion", "Partitions", "MaxTimestamp", "DynamicPartitionMetadata" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Extent : pb::IMessage<Extent> {
    private static readonly pb::MessageParser<Extent> _parser = new pb::MessageParser<Extent>(() => new Extent());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Extent> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Extent() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Extent(Extent other) : this() {
      _hasBits0 = other._hasBits0;
      startBlock_ = other.startBlock_;
      numBlocks_ = other.numBlocks_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Extent Clone() {
      return new Extent(this);
    }

    /// <summary>Field number for the "start_block" field.</summary>
    public const int StartBlockFieldNumber = 1;
    private readonly static ulong StartBlockDefaultValue = 0UL;

    private ulong startBlock_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong StartBlock {
      get { if ((_hasBits0 & 1) != 0) { return startBlock_; } else { return StartBlockDefaultValue; } }
      set {
        _hasBits0 |= 1;
        startBlock_ = value;
      }
    }
    /// <summary>Gets whether the "start_block" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStartBlock {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "start_block" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStartBlock() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "num_blocks" field.</summary>
    public const int NumBlocksFieldNumber = 2;
    private readonly static ulong NumBlocksDefaultValue = 0UL;

    private ulong numBlocks_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong NumBlocks {
      get { if ((_hasBits0 & 2) != 0) { return numBlocks_; } else { return NumBlocksDefaultValue; } }
      set {
        _hasBits0 |= 2;
        numBlocks_ = value;
      }
    }
    /// <summary>Gets whether the "num_blocks" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasNumBlocks {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "num_blocks" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearNumBlocks() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Extent);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Extent other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartBlock != other.StartBlock) return false;
      if (NumBlocks != other.NumBlocks) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasStartBlock) hash ^= StartBlock.GetHashCode();
      if (HasNumBlocks) hash ^= NumBlocks.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasStartBlock) {
        output.WriteRawTag(8);
        output.WriteUInt64(StartBlock);
      }
      if (HasNumBlocks) {
        output.WriteRawTag(16);
        output.WriteUInt64(NumBlocks);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasStartBlock) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(StartBlock);
      }
      if (HasNumBlocks) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(NumBlocks);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Extent other) {
      if (other == null) {
        return;
      }
      if (other.HasStartBlock) {
        StartBlock = other.StartBlock;
      }
      if (other.HasNumBlocks) {
        NumBlocks = other.NumBlocks;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            StartBlock = input.ReadUInt64();
            break;
          }
          case 16: {
            NumBlocks = input.ReadUInt64();
            break;
          }
        }
      }
    }

  }

  public sealed partial class Signatures : pb::IMessage<Signatures> {
    private static readonly pb::MessageParser<Signatures> _parser = new pb::MessageParser<Signatures>(() => new Signatures());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Signatures> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Signatures() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Signatures(Signatures other) : this() {
      signatures_ = other.signatures_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Signatures Clone() {
      return new Signatures(this);
    }

    /// <summary>Field number for the "signatures" field.</summary>
    public const int Signatures_FieldNumber = 1;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Signatures.Types.Signature> _repeated_signatures_codec
        = pb::FieldCodec.ForMessage(10, global::ChromeosUpdateEngine.Signatures.Types.Signature.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> signatures_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> Signatures_ {
      get { return signatures_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Signatures);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Signatures other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!signatures_.Equals(other.signatures_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= signatures_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      signatures_.WriteTo(output, _repeated_signatures_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += signatures_.CalculateSize(_repeated_signatures_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Signatures other) {
      if (other == null) {
        return;
      }
      signatures_.Add(other.signatures_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            signatures_.AddEntriesFrom(input, _repeated_signatures_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Signatures message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Signature : pb::IMessage<Signature> {
        private static readonly pb::MessageParser<Signature> _parser = new pb::MessageParser<Signature>(() => new Signature());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Signature> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::ChromeosUpdateEngine.Signatures.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Signature() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Signature(Signature other) : this() {
          _hasBits0 = other._hasBits0;
          version_ = other.version_;
          data_ = other.data_;
          unpaddedSignatureSize_ = other.unpaddedSignatureSize_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Signature Clone() {
          return new Signature(this);
        }

        /// <summary>Field number for the "version" field.</summary>
        public const int VersionFieldNumber = 1;
        private readonly static uint VersionDefaultValue = 0;

        private uint version_;
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint Version {
          get { if ((_hasBits0 & 1) != 0) { return version_; } else { return VersionDefaultValue; } }
          set {
            _hasBits0 |= 1;
            version_ = value;
          }
        }
        /// <summary>Gets whether the "version" field is set</summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasVersion {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "version" field</summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearVersion() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "data" field.</summary>
        public const int DataFieldNumber = 2;
        private readonly static pb::ByteString DataDefaultValue = pb::ByteString.Empty;

        private pb::ByteString data_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString Data {
          get { return data_ ?? DataDefaultValue; }
          set {
            data_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "data" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasData {
          get { return data_ != null; }
        }
        /// <summary>Clears the value of the "data" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearData() {
          data_ = null;
        }

        /// <summary>Field number for the "unpadded_signature_size" field.</summary>
        public const int UnpaddedSignatureSizeFieldNumber = 3;
        private readonly static uint UnpaddedSignatureSizeDefaultValue = 0;

        private uint unpaddedSignatureSize_;
        /// <summary>
        /// The DER encoded signature size of EC keys is nondeterministic for
        /// different input of sha256 hash. However, we need the size of the
        /// serialized signatures protobuf string to be fixed before signing;
        /// because this size is part of the content to be signed. Therefore, we
        /// always pad the signature data to the maximum possible signature size of
        /// a given key. And the payload verifier will truncate the signature to
        /// its correct size based on the value of |unpadded_signature_size|.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint UnpaddedSignatureSize {
          get { if ((_hasBits0 & 2) != 0) { return unpaddedSignatureSize_; } else { return UnpaddedSignatureSizeDefaultValue; } }
          set {
            _hasBits0 |= 2;
            unpaddedSignatureSize_ = value;
          }
        }
        /// <summary>Gets whether the "unpadded_signature_size" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool HasUnpaddedSignatureSize {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "unpadded_signature_size" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearUnpaddedSignatureSize() {
          _hasBits0 &= ~2;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Signature);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Signature other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Version != other.Version) return false;
          if (Data != other.Data) return false;
          if (UnpaddedSignatureSize != other.UnpaddedSignatureSize) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (HasVersion) hash ^= Version.GetHashCode();
          if (HasData) hash ^= Data.GetHashCode();
          if (HasUnpaddedSignatureSize) hash ^= UnpaddedSignatureSize.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (HasVersion) {
            output.WriteRawTag(8);
            output.WriteUInt32(Version);
          }
          if (HasData) {
            output.WriteRawTag(18);
            output.WriteBytes(Data);
          }
          if (HasUnpaddedSignatureSize) {
            output.WriteRawTag(29);
            output.WriteFixed32(UnpaddedSignatureSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (HasVersion) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Version);
          }
          if (HasData) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Data);
          }
          if (HasUnpaddedSignatureSize) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Signature other) {
          if (other == null) {
            return;
          }
          if (other.HasVersion) {
            Version = other.Version;
          }
          if (other.HasData) {
            Data = other.Data;
          }
          if (other.HasUnpaddedSignatureSize) {
            UnpaddedSignatureSize = other.UnpaddedSignatureSize;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Version = input.ReadUInt32();
                break;
              }
              case 18: {
                Data = input.ReadBytes();
                break;
              }
              case 29: {
                UnpaddedSignatureSize = input.ReadFixed32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class PartitionInfo : pb::IMessage<PartitionInfo> {
    private static readonly pb::MessageParser<PartitionInfo> _parser = new pb::MessageParser<PartitionInfo>(() => new PartitionInfo());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PartitionInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PartitionInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PartitionInfo(PartitionInfo other) : this() {
      _hasBits0 = other._hasBits0;
      size_ = other.size_;
      hash_ = other.hash_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PartitionInfo Clone() {
      return new PartitionInfo(this);
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 1;
    private readonly static ulong SizeDefaultValue = 0UL;

    private ulong size_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "hash" field.</summary>
    public const int HashFieldNumber = 2;
    private readonly static pb::ByteString HashDefaultValue = pb::ByteString.Empty;

    private pb::ByteString hash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString Hash {
      get { return hash_ ?? HashDefaultValue; }
      set {
        hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hash" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHash {
      get { return hash_ != null; }
    }
    /// <summary>Clears the value of the "hash" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHash() {
      hash_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PartitionInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PartitionInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Size != other.Size) return false;
      if (Hash != other.Hash) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSize) hash ^= Size.GetHashCode();
      if (HasHash) hash ^= Hash.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasSize) {
        output.WriteRawTag(8);
        output.WriteUInt64(Size);
      }
      if (HasHash) {
        output.WriteRawTag(18);
        output.WriteBytes(Hash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Size);
      }
      if (HasHash) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Hash);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PartitionInfo other) {
      if (other == null) {
        return;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      if (other.HasHash) {
        Hash = other.Hash;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Size = input.ReadUInt64();
            break;
          }
          case 18: {
            Hash = input.ReadBytes();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Describe an image we are based on in a human friendly way.
  /// Examples:
  ///   dev-channel, x86-alex, 1.2.3, mp-v3
  ///   nplusone-channel, x86-alex, 1.2.4, mp-v3, dev-channel, 1.2.3
  ///
  /// All fields will be set, if this message is present.
  /// </summary>
  public sealed partial class ImageInfo : pb::IMessage<ImageInfo> {
    private static readonly pb::MessageParser<ImageInfo> _parser = new pb::MessageParser<ImageInfo>(() => new ImageInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ImageInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageInfo(ImageInfo other) : this() {
      board_ = other.board_;
      key_ = other.key_;
      channel_ = other.channel_;
      version_ = other.version_;
      buildChannel_ = other.buildChannel_;
      buildVersion_ = other.buildVersion_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ImageInfo Clone() {
      return new ImageInfo(this);
    }

    /// <summary>Field number for the "board" field.</summary>
    public const int BoardFieldNumber = 1;
    private readonly static string BoardDefaultValue = "";

    private string board_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Board {
      get { return board_ ?? BoardDefaultValue; }
      set {
        board_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "board" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBoard {
      get { return board_ != null; }
    }
    /// <summary>Clears the value of the "board" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBoard() {
      board_ = null;
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 2;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "channel" field.</summary>
    public const int ChannelFieldNumber = 3;
    private readonly static string ChannelDefaultValue = "";

    private string channel_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Channel {
      get { return channel_ ?? ChannelDefaultValue; }
      set {
        channel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "channel" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasChannel {
      get { return channel_ != null; }
    }
    /// <summary>Clears the value of the "channel" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearChannel() {
      channel_ = null;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 4;
    private readonly static string VersionDefaultValue = "";

    private string version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Version {
      get { return version_ ?? VersionDefaultValue; }
      set {
        version_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVersion {
      get { return version_ != null; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVersion() {
      version_ = null;
    }

    /// <summary>Field number for the "build_channel" field.</summary>
    public const int BuildChannelFieldNumber = 5;
    private readonly static string BuildChannelDefaultValue = "";

    private string buildChannel_;
    /// <summary>
    /// If these values aren't present, they should be assumed to match
    /// the equivalent value above. They are normally only different for
    /// special image types such as nplusone images.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BuildChannel {
      get { return buildChannel_ ?? BuildChannelDefaultValue; }
      set {
        buildChannel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "build_channel" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBuildChannel {
      get { return buildChannel_ != null; }
    }
    /// <summary>Clears the value of the "build_channel" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBuildChannel() {
      buildChannel_ = null;
    }

    /// <summary>Field number for the "build_version" field.</summary>
    public const int BuildVersionFieldNumber = 6;
    private readonly static string BuildVersionDefaultValue = "";

    private string buildVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BuildVersion {
      get { return buildVersion_ ?? BuildVersionDefaultValue; }
      set {
        buildVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "build_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBuildVersion {
      get { return buildVersion_ != null; }
    }
    /// <summary>Clears the value of the "build_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBuildVersion() {
      buildVersion_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ImageInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ImageInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Board != other.Board) return false;
      if (Key != other.Key) return false;
      if (Channel != other.Channel) return false;
      if (Version != other.Version) return false;
      if (BuildChannel != other.BuildChannel) return false;
      if (BuildVersion != other.BuildVersion) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasBoard) hash ^= Board.GetHashCode();
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasChannel) hash ^= Channel.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      if (HasBuildChannel) hash ^= BuildChannel.GetHashCode();
      if (HasBuildVersion) hash ^= BuildVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasBoard) {
        output.WriteRawTag(10);
        output.WriteString(Board);
      }
      if (HasKey) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      if (HasChannel) {
        output.WriteRawTag(26);
        output.WriteString(Channel);
      }
      if (HasVersion) {
        output.WriteRawTag(34);
        output.WriteString(Version);
      }
      if (HasBuildChannel) {
        output.WriteRawTag(42);
        output.WriteString(BuildChannel);
      }
      if (HasBuildVersion) {
        output.WriteRawTag(50);
        output.WriteString(BuildVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasBoard) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Board);
      }
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasChannel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Channel);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Version);
      }
      if (HasBuildChannel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BuildChannel);
      }
      if (HasBuildVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BuildVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ImageInfo other) {
      if (other == null) {
        return;
      }
      if (other.HasBoard) {
        Board = other.Board;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasChannel) {
        Channel = other.Channel;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      if (other.HasBuildChannel) {
        BuildChannel = other.BuildChannel;
      }
      if (other.HasBuildVersion) {
        BuildVersion = other.BuildVersion;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Board = input.ReadString();
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 26: {
            Channel = input.ReadString();
            break;
          }
          case 34: {
            Version = input.ReadString();
            break;
          }
          case 42: {
            BuildChannel = input.ReadString();
            break;
          }
          case 50: {
            BuildVersion = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class InstallOperation : pb::IMessage<InstallOperation> {
    private static readonly pb::MessageParser<InstallOperation> _parser = new pb::MessageParser<InstallOperation>(() => new InstallOperation());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InstallOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallOperation(InstallOperation other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      dataOffset_ = other.dataOffset_;
      dataLength_ = other.dataLength_;
      srcExtents_ = other.srcExtents_.Clone();
      srcLength_ = other.srcLength_;
      dstExtents_ = other.dstExtents_.Clone();
      dstLength_ = other.dstLength_;
      dataSha256Hash_ = other.dataSha256Hash_;
      srcSha256Hash_ = other.srcSha256Hash_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstallOperation Clone() {
      return new InstallOperation(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::ChromeosUpdateEngine.InstallOperation.Types.Type TypeDefaultValue = global::ChromeosUpdateEngine.InstallOperation.Types.Type.Replace;

    private global::ChromeosUpdateEngine.InstallOperation.Types.Type type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.InstallOperation.Types.Type Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "data_offset" field.</summary>
    public const int DataOffsetFieldNumber = 2;
    private readonly static ulong DataOffsetDefaultValue = 0UL;

    private ulong dataOffset_;
    /// <summary>
    /// Only minor version 6 or newer support 64 bits |data_offset| and
    /// |data_length|, older client will read them as uint32.
    /// The offset into the delta file (after the protobuf)
    /// where the data (if any) is stored
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong DataOffset {
      get { if ((_hasBits0 & 2) != 0) { return dataOffset_; } else { return DataOffsetDefaultValue; } }
      set {
        _hasBits0 |= 2;
        dataOffset_ = value;
      }
    }
    /// <summary>Gets whether the "data_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDataOffset {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "data_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDataOffset() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "data_length" field.</summary>
    public const int DataLengthFieldNumber = 3;
    private readonly static ulong DataLengthDefaultValue = 0UL;

    private ulong dataLength_;
    /// <summary>
    /// The length of the data in the delta file
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong DataLength {
      get { if ((_hasBits0 & 4) != 0) { return dataLength_; } else { return DataLengthDefaultValue; } }
      set {
        _hasBits0 |= 4;
        dataLength_ = value;
      }
    }
    /// <summary>Gets whether the "data_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDataLength {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "data_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDataLength() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "src_extents" field.</summary>
    public const int SrcExtentsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Extent> _repeated_srcExtents_codec
        = pb::FieldCodec.ForMessage(34, global::ChromeosUpdateEngine.Extent.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> srcExtents_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Extent>();
    /// <summary>
    /// Ordered list of extents that are read from (if any) and written to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> SrcExtents {
      get { return srcExtents_; }
    }

    /// <summary>Field number for the "src_length" field.</summary>
    public const int SrcLengthFieldNumber = 5;
    private readonly static ulong SrcLengthDefaultValue = 0UL;

    private ulong srcLength_;
    /// <summary>
    /// Byte length of src, equal to the number of blocks in src_extents *
    /// block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
    /// pass that external program the number of bytes to read from the blocks we
    /// pass it.  This is not used in any other operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong SrcLength {
      get { if ((_hasBits0 & 8) != 0) { return srcLength_; } else { return SrcLengthDefaultValue; } }
      set {
        _hasBits0 |= 8;
        srcLength_ = value;
      }
    }
    /// <summary>Gets whether the "src_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSrcLength {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "src_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSrcLength() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "dst_extents" field.</summary>
    public const int DstExtentsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Extent> _repeated_dstExtents_codec
        = pb::FieldCodec.ForMessage(50, global::ChromeosUpdateEngine.Extent.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> dstExtents_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Extent>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Extent> DstExtents {
      get { return dstExtents_; }
    }

    /// <summary>Field number for the "dst_length" field.</summary>
    public const int DstLengthFieldNumber = 7;
    private readonly static ulong DstLengthDefaultValue = 0UL;

    private ulong dstLength_;
    /// <summary>
    /// Byte length of dst, equal to the number of blocks in dst_extents *
    /// block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
    /// operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong DstLength {
      get { if ((_hasBits0 & 16) != 0) { return dstLength_; } else { return DstLengthDefaultValue; } }
      set {
        _hasBits0 |= 16;
        dstLength_ = value;
      }
    }
    /// <summary>Gets whether the "dst_length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDstLength {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "dst_length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDstLength() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "data_sha256_hash" field.</summary>
    public const int DataSha256HashFieldNumber = 8;
    private readonly static pb::ByteString DataSha256HashDefaultValue = pb::ByteString.Empty;

    private pb::ByteString dataSha256Hash_;
    /// <summary>
    /// Optional SHA 256 hash of the blob associated with this operation.
    /// This is used as a primary validation for http-based downloads and
    /// as a defense-in-depth validation for https-based downloads. If
    /// the operation doesn't refer to any blob, this field will have
    /// zero bytes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString DataSha256Hash {
      get { return dataSha256Hash_ ?? DataSha256HashDefaultValue; }
      set {
        dataSha256Hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "data_sha256_hash" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasDataSha256Hash {
      get { return dataSha256Hash_ != null; }
    }
    /// <summary>Clears the value of the "data_sha256_hash" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearDataSha256Hash() {
      dataSha256Hash_ = null;
    }

    /// <summary>Field number for the "src_sha256_hash" field.</summary>
    public const int SrcSha256HashFieldNumber = 9;
    private readonly static pb::ByteString SrcSha256HashDefaultValue = pb::ByteString.Empty;

    private pb::ByteString srcSha256Hash_;
    /// <summary>
    /// Indicates the SHA 256 hash of the source data referenced in src_extents at
    /// the time of applying the operation. If present, the update_engine daemon
    /// MUST read and verify the source data before applying the operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString SrcSha256Hash {
      get { return srcSha256Hash_ ?? SrcSha256HashDefaultValue; }
      set {
        srcSha256Hash_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "src_sha256_hash" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSrcSha256Hash {
      get { return srcSha256Hash_ != null; }
    }
    /// <summary>Clears the value of the "src_sha256_hash" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSrcSha256Hash() {
      srcSha256Hash_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InstallOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InstallOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (DataOffset != other.DataOffset) return false;
      if (DataLength != other.DataLength) return false;
      if(!srcExtents_.Equals(other.srcExtents_)) return false;
      if (SrcLength != other.SrcLength) return false;
      if(!dstExtents_.Equals(other.dstExtents_)) return false;
      if (DstLength != other.DstLength) return false;
      if (DataSha256Hash != other.DataSha256Hash) return false;
      if (SrcSha256Hash != other.SrcSha256Hash) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasDataOffset) hash ^= DataOffset.GetHashCode();
      if (HasDataLength) hash ^= DataLength.GetHashCode();
      hash ^= srcExtents_.GetHashCode();
      if (HasSrcLength) hash ^= SrcLength.GetHashCode();
      hash ^= dstExtents_.GetHashCode();
      if (HasDstLength) hash ^= DstLength.GetHashCode();
      if (HasDataSha256Hash) hash ^= DataSha256Hash.GetHashCode();
      if (HasSrcSha256Hash) hash ^= SrcSha256Hash.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasDataOffset) {
        output.WriteRawTag(16);
        output.WriteUInt64(DataOffset);
      }
      if (HasDataLength) {
        output.WriteRawTag(24);
        output.WriteUInt64(DataLength);
      }
      srcExtents_.WriteTo(output, _repeated_srcExtents_codec);
      if (HasSrcLength) {
        output.WriteRawTag(40);
        output.WriteUInt64(SrcLength);
      }
      dstExtents_.WriteTo(output, _repeated_dstExtents_codec);
      if (HasDstLength) {
        output.WriteRawTag(56);
        output.WriteUInt64(DstLength);
      }
      if (HasDataSha256Hash) {
        output.WriteRawTag(66);
        output.WriteBytes(DataSha256Hash);
      }
      if (HasSrcSha256Hash) {
        output.WriteRawTag(74);
        output.WriteBytes(SrcSha256Hash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasDataOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DataOffset);
      }
      if (HasDataLength) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DataLength);
      }
      size += srcExtents_.CalculateSize(_repeated_srcExtents_codec);
      if (HasSrcLength) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SrcLength);
      }
      size += dstExtents_.CalculateSize(_repeated_dstExtents_codec);
      if (HasDstLength) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DstLength);
      }
      if (HasDataSha256Hash) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DataSha256Hash);
      }
      if (HasSrcSha256Hash) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SrcSha256Hash);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InstallOperation other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasDataOffset) {
        DataOffset = other.DataOffset;
      }
      if (other.HasDataLength) {
        DataLength = other.DataLength;
      }
      srcExtents_.Add(other.srcExtents_);
      if (other.HasSrcLength) {
        SrcLength = other.SrcLength;
      }
      dstExtents_.Add(other.dstExtents_);
      if (other.HasDstLength) {
        DstLength = other.DstLength;
      }
      if (other.HasDataSha256Hash) {
        DataSha256Hash = other.DataSha256Hash;
      }
      if (other.HasSrcSha256Hash) {
        SrcSha256Hash = other.SrcSha256Hash;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::ChromeosUpdateEngine.InstallOperation.Types.Type) input.ReadEnum();
            break;
          }
          case 16: {
            DataOffset = input.ReadUInt64();
            break;
          }
          case 24: {
            DataLength = input.ReadUInt64();
            break;
          }
          case 34: {
            srcExtents_.AddEntriesFrom(input, _repeated_srcExtents_codec);
            break;
          }
          case 40: {
            SrcLength = input.ReadUInt64();
            break;
          }
          case 50: {
            dstExtents_.AddEntriesFrom(input, _repeated_dstExtents_codec);
            break;
          }
          case 56: {
            DstLength = input.ReadUInt64();
            break;
          }
          case 66: {
            DataSha256Hash = input.ReadBytes();
            break;
          }
          case 74: {
            SrcSha256Hash = input.ReadBytes();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the InstallOperation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Type {
        /// <summary>
        /// Replace destination extents w/ attached data
        /// </summary>
        [pbr::OriginalName("REPLACE")] Replace = 0,
        /// <summary>
        /// Replace destination extents w/ attached bzipped data
        /// </summary>
        [pbr::OriginalName("REPLACE_BZ")] ReplaceBz = 1,
        /// <summary>
        /// Move source extents to destination extents
        /// </summary>
        [pbr::OriginalName("MOVE")] Move = 2,
        /// <summary>
        /// The data is a bsdiff binary diff
        /// </summary>
        [pbr::OriginalName("BSDIFF")] Bsdiff = 3,
        /// <summary>
        /// On minor version 2 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("SOURCE_COPY")] SourceCopy = 4,
        /// <summary>
        /// Like BSDIFF, but read from source partition
        /// </summary>
        [pbr::OriginalName("SOURCE_BSDIFF")] SourceBsdiff = 5,
        /// <summary>
        /// On minor version 3 or newer and on major version 2 or newer, these
        /// operations are supported:
        /// </summary>
        [pbr::OriginalName("REPLACE_XZ")] ReplaceXz = 8,
        /// <summary>
        /// On minor version 4 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("ZERO")] Zero = 6,
        /// <summary>
        /// Discard the destination blocks, reading as undefined.
        /// </summary>
        [pbr::OriginalName("DISCARD")] Discard = 7,
        /// <summary>
        /// Like SOURCE_BSDIFF, but compressed with brotli.
        /// </summary>
        [pbr::OriginalName("BROTLI_BSDIFF")] BrotliBsdiff = 10,
        /// <summary>
        /// On minor version 5 or newer, these operations are supported:
        /// </summary>
        [pbr::OriginalName("PUFFDIFF")] Puffdiff = 9,
      }

    }
    #endregion

  }

  /// <summary>
  /// Describes the update to apply to a single partition.
  /// </summary>
  public sealed partial class PartitionUpdate : pb::IMessage<PartitionUpdate> {
    private static readonly pb::MessageParser<PartitionUpdate> _parser = new pb::MessageParser<PartitionUpdate>(() => new PartitionUpdate());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PartitionUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PartitionUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PartitionUpdate(PartitionUpdate other) : this() {
      _hasBits0 = other._hasBits0;
      partitionName_ = other.partitionName_;
      runPostinstall_ = other.runPostinstall_;
      postinstallPath_ = other.postinstallPath_;
      filesystemType_ = other.filesystemType_;
      newPartitionSignature_ = other.newPartitionSignature_.Clone();
      oldPartitionInfo_ = other.oldPartitionInfo_ != null ? other.oldPartitionInfo_.Clone() : null;
      newPartitionInfo_ = other.newPartitionInfo_ != null ? other.newPartitionInfo_.Clone() : null;
      operations_ = other.operations_.Clone();
      postinstallOptional_ = other.postinstallOptional_;
      hashTreeDataExtent_ = other.hashTreeDataExtent_ != null ? other.hashTreeDataExtent_.Clone() : null;
      hashTreeExtent_ = other.hashTreeExtent_ != null ? other.hashTreeExtent_.Clone() : null;
      hashTreeAlgorithm_ = other.hashTreeAlgorithm_;
      hashTreeSalt_ = other.hashTreeSalt_;
      fecDataExtent_ = other.fecDataExtent_ != null ? other.fecDataExtent_.Clone() : null;
      fecExtent_ = other.fecExtent_ != null ? other.fecExtent_.Clone() : null;
      fecRoots_ = other.fecRoots_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PartitionUpdate Clone() {
      return new PartitionUpdate(this);
    }

    /// <summary>Field number for the "partition_name" field.</summary>
    public const int PartitionNameFieldNumber = 1;
    private readonly static string PartitionNameDefaultValue = "";

    private string partitionName_;
    /// <summary>
    /// A platform-specific name to identify the partition set being updated. For
    /// example, in Chrome OS this could be "ROOT" or "KERNEL".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PartitionName {
      get { return partitionName_ ?? PartitionNameDefaultValue; }
      set {
        partitionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "partition_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPartitionName {
      get { return partitionName_ != null; }
    }
    /// <summary>Clears the value of the "partition_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPartitionName() {
      partitionName_ = null;
    }

    /// <summary>Field number for the "run_postinstall" field.</summary>
    public const int RunPostinstallFieldNumber = 2;
    private readonly static bool RunPostinstallDefaultValue = false;

    private bool runPostinstall_;
    /// <summary>
    /// Whether this partition carries a filesystem with post-install program that
    /// must be run to finalize the update process. See also |postinstall_path| and
    /// |filesystem_type|.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RunPostinstall {
      get { if ((_hasBits0 & 1) != 0) { return runPostinstall_; } else { return RunPostinstallDefaultValue; } }
      set {
        _hasBits0 |= 1;
        runPostinstall_ = value;
      }
    }
    /// <summary>Gets whether the "run_postinstall" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRunPostinstall {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "run_postinstall" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRunPostinstall() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "postinstall_path" field.</summary>
    public const int PostinstallPathFieldNumber = 3;
    private readonly static string PostinstallPathDefaultValue = "";

    private string postinstallPath_;
    /// <summary>
    /// The path of the executable program to run during the post-install step,
    /// relative to the root of this filesystem. If not set, the default "postinst"
    /// will be used. This setting is only used when |run_postinstall| is set and
    /// true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PostinstallPath {
      get { return postinstallPath_ ?? PostinstallPathDefaultValue; }
      set {
        postinstallPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "postinstall_path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostinstallPath {
      get { return postinstallPath_ != null; }
    }
    /// <summary>Clears the value of the "postinstall_path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostinstallPath() {
      postinstallPath_ = null;
    }

    /// <summary>Field number for the "filesystem_type" field.</summary>
    public const int FilesystemTypeFieldNumber = 4;
    private readonly static string FilesystemTypeDefaultValue = "";

    private string filesystemType_;
    /// <summary>
    /// The filesystem type as passed to the mount(2) syscall when mounting the new
    /// filesystem to run the post-install program. If not set, a fixed list of
    /// filesystems will be attempted. This setting is only used if
    /// |run_postinstall| is set and true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FilesystemType {
      get { return filesystemType_ ?? FilesystemTypeDefaultValue; }
      set {
        filesystemType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "filesystem_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFilesystemType {
      get { return filesystemType_ != null; }
    }
    /// <summary>Clears the value of the "filesystem_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFilesystemType() {
      filesystemType_ = null;
    }

    /// <summary>Field number for the "new_partition_signature" field.</summary>
    public const int NewPartitionSignatureFieldNumber = 5;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.Signatures.Types.Signature> _repeated_newPartitionSignature_codec
        = pb::FieldCodec.ForMessage(42, global::ChromeosUpdateEngine.Signatures.Types.Signature.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> newPartitionSignature_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature>();
    /// <summary>
    /// If present, a list of signatures of the new_partition_info.hash signed with
    /// different keys. If the update_engine daemon requires vendor-signed images
    /// and has its public key installed, one of the signatures should be valid
    /// for /postinstall to run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.Signatures.Types.Signature> NewPartitionSignature {
      get { return newPartitionSignature_; }
    }

    /// <summary>Field number for the "old_partition_info" field.</summary>
    public const int OldPartitionInfoFieldNumber = 6;
    private global::ChromeosUpdateEngine.PartitionInfo oldPartitionInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.PartitionInfo OldPartitionInfo {
      get { return oldPartitionInfo_; }
      set {
        oldPartitionInfo_ = value;
      }
    }

    /// <summary>Field number for the "new_partition_info" field.</summary>
    public const int NewPartitionInfoFieldNumber = 7;
    private global::ChromeosUpdateEngine.PartitionInfo newPartitionInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.PartitionInfo NewPartitionInfo {
      get { return newPartitionInfo_; }
      set {
        newPartitionInfo_ = value;
      }
    }

    /// <summary>Field number for the "operations" field.</summary>
    public const int OperationsFieldNumber = 8;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.InstallOperation> _repeated_operations_codec
        = pb::FieldCodec.ForMessage(66, global::ChromeosUpdateEngine.InstallOperation.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> operations_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation>();
    /// <summary>
    /// The list of operations to be performed to apply this PartitionUpdate. The
    /// associated operation blobs (in operations[i].data_offset, data_length)
    /// should be stored contiguously and in the same order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> Operations {
      get { return operations_; }
    }

    /// <summary>Field number for the "postinstall_optional" field.</summary>
    public const int PostinstallOptionalFieldNumber = 9;
    private readonly static bool PostinstallOptionalDefaultValue = false;

    private bool postinstallOptional_;
    /// <summary>
    /// Whether a failure in the postinstall step for this partition should be
    /// ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PostinstallOptional {
      get { if ((_hasBits0 & 2) != 0) { return postinstallOptional_; } else { return PostinstallOptionalDefaultValue; } }
      set {
        _hasBits0 |= 2;
        postinstallOptional_ = value;
      }
    }
    /// <summary>Gets whether the "postinstall_optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPostinstallOptional {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "postinstall_optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPostinstallOptional() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "hash_tree_data_extent" field.</summary>
    public const int HashTreeDataExtentFieldNumber = 10;
    private global::ChromeosUpdateEngine.Extent hashTreeDataExtent_;
    /// <summary>
    /// The extent for data covered by verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.Extent HashTreeDataExtent {
      get { return hashTreeDataExtent_; }
      set {
        hashTreeDataExtent_ = value;
      }
    }

    /// <summary>Field number for the "hash_tree_extent" field.</summary>
    public const int HashTreeExtentFieldNumber = 11;
    private global::ChromeosUpdateEngine.Extent hashTreeExtent_;
    /// <summary>
    /// The extent to store verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.Extent HashTreeExtent {
      get { return hashTreeExtent_; }
      set {
        hashTreeExtent_ = value;
      }
    }

    /// <summary>Field number for the "hash_tree_algorithm" field.</summary>
    public const int HashTreeAlgorithmFieldNumber = 12;
    private readonly static string HashTreeAlgorithmDefaultValue = "";

    private string hashTreeAlgorithm_;
    /// <summary>
    /// The hash algorithm used in verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HashTreeAlgorithm {
      get { return hashTreeAlgorithm_ ?? HashTreeAlgorithmDefaultValue; }
      set {
        hashTreeAlgorithm_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hash_tree_algorithm" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHashTreeAlgorithm {
      get { return hashTreeAlgorithm_ != null; }
    }
    /// <summary>Clears the value of the "hash_tree_algorithm" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHashTreeAlgorithm() {
      hashTreeAlgorithm_ = null;
    }

    /// <summary>Field number for the "hash_tree_salt" field.</summary>
    public const int HashTreeSaltFieldNumber = 13;
    private readonly static pb::ByteString HashTreeSaltDefaultValue = pb::ByteString.Empty;

    private pb::ByteString hashTreeSalt_;
    /// <summary>
    /// The salt used for verity hash tree.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString HashTreeSalt {
      get { return hashTreeSalt_ ?? HashTreeSaltDefaultValue; }
      set {
        hashTreeSalt_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hash_tree_salt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHashTreeSalt {
      get { return hashTreeSalt_ != null; }
    }
    /// <summary>Clears the value of the "hash_tree_salt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHashTreeSalt() {
      hashTreeSalt_ = null;
    }

    /// <summary>Field number for the "fec_data_extent" field.</summary>
    public const int FecDataExtentFieldNumber = 14;
    private global::ChromeosUpdateEngine.Extent fecDataExtent_;
    /// <summary>
    /// The extent for data covered by FEC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.Extent FecDataExtent {
      get { return fecDataExtent_; }
      set {
        fecDataExtent_ = value;
      }
    }

    /// <summary>Field number for the "fec_extent" field.</summary>
    public const int FecExtentFieldNumber = 15;
    private global::ChromeosUpdateEngine.Extent fecExtent_;
    /// <summary>
    /// The extent to store FEC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.Extent FecExtent {
      get { return fecExtent_; }
      set {
        fecExtent_ = value;
      }
    }

    /// <summary>Field number for the "fec_roots" field.</summary>
    public const int FecRootsFieldNumber = 16;
    private readonly static uint FecRootsDefaultValue = 2;

    private uint fecRoots_;
    /// <summary>
    /// The number of FEC roots.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint FecRoots {
      get { if ((_hasBits0 & 4) != 0) { return fecRoots_; } else { return FecRootsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        fecRoots_ = value;
      }
    }
    /// <summary>Gets whether the "fec_roots" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFecRoots {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "fec_roots" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFecRoots() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PartitionUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PartitionUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PartitionName != other.PartitionName) return false;
      if (RunPostinstall != other.RunPostinstall) return false;
      if (PostinstallPath != other.PostinstallPath) return false;
      if (FilesystemType != other.FilesystemType) return false;
      if(!newPartitionSignature_.Equals(other.newPartitionSignature_)) return false;
      if (!object.Equals(OldPartitionInfo, other.OldPartitionInfo)) return false;
      if (!object.Equals(NewPartitionInfo, other.NewPartitionInfo)) return false;
      if(!operations_.Equals(other.operations_)) return false;
      if (PostinstallOptional != other.PostinstallOptional) return false;
      if (!object.Equals(HashTreeDataExtent, other.HashTreeDataExtent)) return false;
      if (!object.Equals(HashTreeExtent, other.HashTreeExtent)) return false;
      if (HashTreeAlgorithm != other.HashTreeAlgorithm) return false;
      if (HashTreeSalt != other.HashTreeSalt) return false;
      if (!object.Equals(FecDataExtent, other.FecDataExtent)) return false;
      if (!object.Equals(FecExtent, other.FecExtent)) return false;
      if (FecRoots != other.FecRoots) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPartitionName) hash ^= PartitionName.GetHashCode();
      if (HasRunPostinstall) hash ^= RunPostinstall.GetHashCode();
      if (HasPostinstallPath) hash ^= PostinstallPath.GetHashCode();
      if (HasFilesystemType) hash ^= FilesystemType.GetHashCode();
      hash ^= newPartitionSignature_.GetHashCode();
      if (oldPartitionInfo_ != null) hash ^= OldPartitionInfo.GetHashCode();
      if (newPartitionInfo_ != null) hash ^= NewPartitionInfo.GetHashCode();
      hash ^= operations_.GetHashCode();
      if (HasPostinstallOptional) hash ^= PostinstallOptional.GetHashCode();
      if (hashTreeDataExtent_ != null) hash ^= HashTreeDataExtent.GetHashCode();
      if (hashTreeExtent_ != null) hash ^= HashTreeExtent.GetHashCode();
      if (HasHashTreeAlgorithm) hash ^= HashTreeAlgorithm.GetHashCode();
      if (HasHashTreeSalt) hash ^= HashTreeSalt.GetHashCode();
      if (fecDataExtent_ != null) hash ^= FecDataExtent.GetHashCode();
      if (fecExtent_ != null) hash ^= FecExtent.GetHashCode();
      if (HasFecRoots) hash ^= FecRoots.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasPartitionName) {
        output.WriteRawTag(10);
        output.WriteString(PartitionName);
      }
      if (HasRunPostinstall) {
        output.WriteRawTag(16);
        output.WriteBool(RunPostinstall);
      }
      if (HasPostinstallPath) {
        output.WriteRawTag(26);
        output.WriteString(PostinstallPath);
      }
      if (HasFilesystemType) {
        output.WriteRawTag(34);
        output.WriteString(FilesystemType);
      }
      newPartitionSignature_.WriteTo(output, _repeated_newPartitionSignature_codec);
      if (oldPartitionInfo_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(OldPartitionInfo);
      }
      if (newPartitionInfo_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NewPartitionInfo);
      }
      operations_.WriteTo(output, _repeated_operations_codec);
      if (HasPostinstallOptional) {
        output.WriteRawTag(72);
        output.WriteBool(PostinstallOptional);
      }
      if (hashTreeDataExtent_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(HashTreeDataExtent);
      }
      if (hashTreeExtent_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(HashTreeExtent);
      }
      if (HasHashTreeAlgorithm) {
        output.WriteRawTag(98);
        output.WriteString(HashTreeAlgorithm);
      }
      if (HasHashTreeSalt) {
        output.WriteRawTag(106);
        output.WriteBytes(HashTreeSalt);
      }
      if (fecDataExtent_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(FecDataExtent);
      }
      if (fecExtent_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(FecExtent);
      }
      if (HasFecRoots) {
        output.WriteRawTag(128, 1);
        output.WriteUInt32(FecRoots);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasPartitionName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PartitionName);
      }
      if (HasRunPostinstall) {
        size += 1 + 1;
      }
      if (HasPostinstallPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PostinstallPath);
      }
      if (HasFilesystemType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FilesystemType);
      }
      size += newPartitionSignature_.CalculateSize(_repeated_newPartitionSignature_codec);
      if (oldPartitionInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OldPartitionInfo);
      }
      if (newPartitionInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewPartitionInfo);
      }
      size += operations_.CalculateSize(_repeated_operations_codec);
      if (HasPostinstallOptional) {
        size += 1 + 1;
      }
      if (hashTreeDataExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HashTreeDataExtent);
      }
      if (hashTreeExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HashTreeExtent);
      }
      if (HasHashTreeAlgorithm) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HashTreeAlgorithm);
      }
      if (HasHashTreeSalt) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(HashTreeSalt);
      }
      if (fecDataExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FecDataExtent);
      }
      if (fecExtent_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FecExtent);
      }
      if (HasFecRoots) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(FecRoots);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PartitionUpdate other) {
      if (other == null) {
        return;
      }
      if (other.HasPartitionName) {
        PartitionName = other.PartitionName;
      }
      if (other.HasRunPostinstall) {
        RunPostinstall = other.RunPostinstall;
      }
      if (other.HasPostinstallPath) {
        PostinstallPath = other.PostinstallPath;
      }
      if (other.HasFilesystemType) {
        FilesystemType = other.FilesystemType;
      }
      newPartitionSignature_.Add(other.newPartitionSignature_);
      if (other.oldPartitionInfo_ != null) {
        if (oldPartitionInfo_ == null) {
          OldPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        OldPartitionInfo.MergeFrom(other.OldPartitionInfo);
      }
      if (other.newPartitionInfo_ != null) {
        if (newPartitionInfo_ == null) {
          NewPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        NewPartitionInfo.MergeFrom(other.NewPartitionInfo);
      }
      operations_.Add(other.operations_);
      if (other.HasPostinstallOptional) {
        PostinstallOptional = other.PostinstallOptional;
      }
      if (other.hashTreeDataExtent_ != null) {
        if (hashTreeDataExtent_ == null) {
          HashTreeDataExtent = new global::ChromeosUpdateEngine.Extent();
        }
        HashTreeDataExtent.MergeFrom(other.HashTreeDataExtent);
      }
      if (other.hashTreeExtent_ != null) {
        if (hashTreeExtent_ == null) {
          HashTreeExtent = new global::ChromeosUpdateEngine.Extent();
        }
        HashTreeExtent.MergeFrom(other.HashTreeExtent);
      }
      if (other.HasHashTreeAlgorithm) {
        HashTreeAlgorithm = other.HashTreeAlgorithm;
      }
      if (other.HasHashTreeSalt) {
        HashTreeSalt = other.HashTreeSalt;
      }
      if (other.fecDataExtent_ != null) {
        if (fecDataExtent_ == null) {
          FecDataExtent = new global::ChromeosUpdateEngine.Extent();
        }
        FecDataExtent.MergeFrom(other.FecDataExtent);
      }
      if (other.fecExtent_ != null) {
        if (fecExtent_ == null) {
          FecExtent = new global::ChromeosUpdateEngine.Extent();
        }
        FecExtent.MergeFrom(other.FecExtent);
      }
      if (other.HasFecRoots) {
        FecRoots = other.FecRoots;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PartitionName = input.ReadString();
            break;
          }
          case 16: {
            RunPostinstall = input.ReadBool();
            break;
          }
          case 26: {
            PostinstallPath = input.ReadString();
            break;
          }
          case 34: {
            FilesystemType = input.ReadString();
            break;
          }
          case 42: {
            newPartitionSignature_.AddEntriesFrom(input, _repeated_newPartitionSignature_codec);
            break;
          }
          case 50: {
            if (oldPartitionInfo_ == null) {
              OldPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(OldPartitionInfo);
            break;
          }
          case 58: {
            if (newPartitionInfo_ == null) {
              NewPartitionInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(NewPartitionInfo);
            break;
          }
          case 66: {
            operations_.AddEntriesFrom(input, _repeated_operations_codec);
            break;
          }
          case 72: {
            PostinstallOptional = input.ReadBool();
            break;
          }
          case 82: {
            if (hashTreeDataExtent_ == null) {
              HashTreeDataExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(HashTreeDataExtent);
            break;
          }
          case 90: {
            if (hashTreeExtent_ == null) {
              HashTreeExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(HashTreeExtent);
            break;
          }
          case 98: {
            HashTreeAlgorithm = input.ReadString();
            break;
          }
          case 106: {
            HashTreeSalt = input.ReadBytes();
            break;
          }
          case 114: {
            if (fecDataExtent_ == null) {
              FecDataExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(FecDataExtent);
            break;
          }
          case 122: {
            if (fecExtent_ == null) {
              FecExtent = new global::ChromeosUpdateEngine.Extent();
            }
            input.ReadMessage(FecExtent);
            break;
          }
          case 128: {
            FecRoots = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class DynamicPartitionGroup : pb::IMessage<DynamicPartitionGroup> {
    private static readonly pb::MessageParser<DynamicPartitionGroup> _parser = new pb::MessageParser<DynamicPartitionGroup>(() => new DynamicPartitionGroup());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DynamicPartitionGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicPartitionGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicPartitionGroup(DynamicPartitionGroup other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      size_ = other.size_;
      partitionNames_ = other.partitionNames_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicPartitionGroup Clone() {
      return new DynamicPartitionGroup(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "size" field.</summary>
    public const int SizeFieldNumber = 2;
    private readonly static ulong SizeDefaultValue = 0UL;

    private ulong size_;
    /// <summary>
    /// Maximum size of the group. The sum of sizes of all partitions in the group
    /// must not exceed the maximum size of the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Size {
      get { if ((_hasBits0 & 1) != 0) { return size_; } else { return SizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        size_ = value;
      }
    }
    /// <summary>Gets whether the "size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "partition_names" field.</summary>
    public const int PartitionNamesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_partitionNames_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> partitionNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of partitions that belong to the group.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> PartitionNames {
      get { return partitionNames_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DynamicPartitionGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DynamicPartitionGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Size != other.Size) return false;
      if(!partitionNames_.Equals(other.partitionNames_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasSize) hash ^= Size.GetHashCode();
      hash ^= partitionNames_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasSize) {
        output.WriteRawTag(16);
        output.WriteUInt64(Size);
      }
      partitionNames_.WriteTo(output, _repeated_partitionNames_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Size);
      }
      size += partitionNames_.CalculateSize(_repeated_partitionNames_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DynamicPartitionGroup other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasSize) {
        Size = other.Size;
      }
      partitionNames_.Add(other.partitionNames_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Size = input.ReadUInt64();
            break;
          }
          case 26: {
            partitionNames_.AddEntriesFrom(input, _repeated_partitionNames_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Metadata related to all dynamic partitions.
  /// </summary>
  public sealed partial class DynamicPartitionMetadata : pb::IMessage<DynamicPartitionMetadata> {
    private static readonly pb::MessageParser<DynamicPartitionMetadata> _parser = new pb::MessageParser<DynamicPartitionMetadata>(() => new DynamicPartitionMetadata());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DynamicPartitionMetadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicPartitionMetadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicPartitionMetadata(DynamicPartitionMetadata other) : this() {
      _hasBits0 = other._hasBits0;
      groups_ = other.groups_.Clone();
      snapshotEnabled_ = other.snapshotEnabled_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicPartitionMetadata Clone() {
      return new DynamicPartitionMetadata(this);
    }

    /// <summary>Field number for the "groups" field.</summary>
    public const int GroupsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.DynamicPartitionGroup> _repeated_groups_codec
        = pb::FieldCodec.ForMessage(10, global::ChromeosUpdateEngine.DynamicPartitionGroup.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.DynamicPartitionGroup> groups_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.DynamicPartitionGroup>();
    /// <summary>
    /// All updatable groups present in |partitions| of this DeltaArchiveManifest.
    /// - If an updatable group is on the device but not in the manifest, it is
    ///   not updated. Hence, the group will not be resized, and partitions cannot
    ///   be added to or removed from the group.
    /// - If an updatable group is in the manifest but not on the device, the group
    ///   is added to the device.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.DynamicPartitionGroup> Groups {
      get { return groups_; }
    }

    /// <summary>Field number for the "snapshot_enabled" field.</summary>
    public const int SnapshotEnabledFieldNumber = 2;
    private readonly static bool SnapshotEnabledDefaultValue = false;

    private bool snapshotEnabled_;
    /// <summary>
    /// Whether dynamic partitions have snapshots during the update. If this is
    /// set to true, the update_engine daemon creates snapshots for all dynamic
    /// partitions if possible. If this is unset, the update_engine daemon MUST
    /// NOT create snapshots for dynamic partitions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SnapshotEnabled {
      get { if ((_hasBits0 & 1) != 0) { return snapshotEnabled_; } else { return SnapshotEnabledDefaultValue; } }
      set {
        _hasBits0 |= 1;
        snapshotEnabled_ = value;
      }
    }
    /// <summary>Gets whether the "snapshot_enabled" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSnapshotEnabled {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "snapshot_enabled" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSnapshotEnabled() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DynamicPartitionMetadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DynamicPartitionMetadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!groups_.Equals(other.groups_)) return false;
      if (SnapshotEnabled != other.SnapshotEnabled) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= groups_.GetHashCode();
      if (HasSnapshotEnabled) hash ^= SnapshotEnabled.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      groups_.WriteTo(output, _repeated_groups_codec);
      if (HasSnapshotEnabled) {
        output.WriteRawTag(16);
        output.WriteBool(SnapshotEnabled);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += groups_.CalculateSize(_repeated_groups_codec);
      if (HasSnapshotEnabled) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DynamicPartitionMetadata other) {
      if (other == null) {
        return;
      }
      groups_.Add(other.groups_);
      if (other.HasSnapshotEnabled) {
        SnapshotEnabled = other.SnapshotEnabled;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            groups_.AddEntriesFrom(input, _repeated_groups_codec);
            break;
          }
          case 16: {
            SnapshotEnabled = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class DeltaArchiveManifest : pb::IMessage<DeltaArchiveManifest> {
    private static readonly pb::MessageParser<DeltaArchiveManifest> _parser = new pb::MessageParser<DeltaArchiveManifest>(() => new DeltaArchiveManifest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeltaArchiveManifest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::ChromeosUpdateEngine.UpdateMetadataReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeltaArchiveManifest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeltaArchiveManifest(DeltaArchiveManifest other) : this() {
      _hasBits0 = other._hasBits0;
      installOperations_ = other.installOperations_.Clone();
      kernelInstallOperations_ = other.kernelInstallOperations_.Clone();
      blockSize_ = other.blockSize_;
      signaturesOffset_ = other.signaturesOffset_;
      signaturesSize_ = other.signaturesSize_;
      oldKernelInfo_ = other.oldKernelInfo_ != null ? other.oldKernelInfo_.Clone() : null;
      newKernelInfo_ = other.newKernelInfo_ != null ? other.newKernelInfo_.Clone() : null;
      oldRootfsInfo_ = other.oldRootfsInfo_ != null ? other.oldRootfsInfo_.Clone() : null;
      newRootfsInfo_ = other.newRootfsInfo_ != null ? other.newRootfsInfo_.Clone() : null;
      oldImageInfo_ = other.oldImageInfo_ != null ? other.oldImageInfo_.Clone() : null;
      newImageInfo_ = other.newImageInfo_ != null ? other.newImageInfo_.Clone() : null;
      minorVersion_ = other.minorVersion_;
      partitions_ = other.partitions_.Clone();
      maxTimestamp_ = other.maxTimestamp_;
      dynamicPartitionMetadata_ = other.dynamicPartitionMetadata_ != null ? other.dynamicPartitionMetadata_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeltaArchiveManifest Clone() {
      return new DeltaArchiveManifest(this);
    }

    /// <summary>Field number for the "install_operations" field.</summary>
    public const int InstallOperationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.InstallOperation> _repeated_installOperations_codec
        = pb::FieldCodec.ForMessage(10, global::ChromeosUpdateEngine.InstallOperation.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> installOperations_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation>();
    /// <summary>
    /// Only present in major version = 1. List of install operations for the
    /// kernel and rootfs partitions. For major version = 2 see the |partitions|
    /// field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> InstallOperations {
      get { return installOperations_; }
    }

    /// <summary>Field number for the "kernel_install_operations" field.</summary>
    public const int KernelInstallOperationsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.InstallOperation> _repeated_kernelInstallOperations_codec
        = pb::FieldCodec.ForMessage(18, global::ChromeosUpdateEngine.InstallOperation.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> kernelInstallOperations_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.InstallOperation> KernelInstallOperations {
      get { return kernelInstallOperations_; }
    }

    /// <summary>Field number for the "block_size" field.</summary>
    public const int BlockSizeFieldNumber = 3;
    private readonly static uint BlockSizeDefaultValue = 4096;

    private uint blockSize_;
    /// <summary>
    /// (At time of writing) usually 4096
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BlockSize {
      get { if ((_hasBits0 & 1) != 0) { return blockSize_; } else { return BlockSizeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        blockSize_ = value;
      }
    }
    /// <summary>Gets whether the "block_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBlockSize {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "block_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBlockSize() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "signatures_offset" field.</summary>
    public const int SignaturesOffsetFieldNumber = 4;
    private readonly static ulong SignaturesOffsetDefaultValue = 0UL;

    private ulong signaturesOffset_;
    /// <summary>
    /// If signatures are present, the offset into the blobs, generally
    /// tacked onto the end of the file, and the length. We use an offset
    /// rather than a bool to allow for more flexibility in future file formats.
    /// If either is absent, it means signatures aren't supported in this
    /// file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong SignaturesOffset {
      get { if ((_hasBits0 & 2) != 0) { return signaturesOffset_; } else { return SignaturesOffsetDefaultValue; } }
      set {
        _hasBits0 |= 2;
        signaturesOffset_ = value;
      }
    }
    /// <summary>Gets whether the "signatures_offset" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSignaturesOffset {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "signatures_offset" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSignaturesOffset() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "signatures_size" field.</summary>
    public const int SignaturesSizeFieldNumber = 5;
    private readonly static ulong SignaturesSizeDefaultValue = 0UL;

    private ulong signaturesSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong SignaturesSize {
      get { if ((_hasBits0 & 4) != 0) { return signaturesSize_; } else { return SignaturesSizeDefaultValue; } }
      set {
        _hasBits0 |= 4;
        signaturesSize_ = value;
      }
    }
    /// <summary>Gets whether the "signatures_size" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasSignaturesSize {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "signatures_size" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSignaturesSize() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "old_kernel_info" field.</summary>
    public const int OldKernelInfoFieldNumber = 6;
    private global::ChromeosUpdateEngine.PartitionInfo oldKernelInfo_;
    /// <summary>
    /// Only present in major version = 1. Partition metadata used to validate the
    /// update. For major version = 2 see the |partitions| field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.PartitionInfo OldKernelInfo {
      get { return oldKernelInfo_; }
      set {
        oldKernelInfo_ = value;
      }
    }

    /// <summary>Field number for the "new_kernel_info" field.</summary>
    public const int NewKernelInfoFieldNumber = 7;
    private global::ChromeosUpdateEngine.PartitionInfo newKernelInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.PartitionInfo NewKernelInfo {
      get { return newKernelInfo_; }
      set {
        newKernelInfo_ = value;
      }
    }

    /// <summary>Field number for the "old_rootfs_info" field.</summary>
    public const int OldRootfsInfoFieldNumber = 8;
    private global::ChromeosUpdateEngine.PartitionInfo oldRootfsInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.PartitionInfo OldRootfsInfo {
      get { return oldRootfsInfo_; }
      set {
        oldRootfsInfo_ = value;
      }
    }

    /// <summary>Field number for the "new_rootfs_info" field.</summary>
    public const int NewRootfsInfoFieldNumber = 9;
    private global::ChromeosUpdateEngine.PartitionInfo newRootfsInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.PartitionInfo NewRootfsInfo {
      get { return newRootfsInfo_; }
      set {
        newRootfsInfo_ = value;
      }
    }

    /// <summary>Field number for the "old_image_info" field.</summary>
    public const int OldImageInfoFieldNumber = 10;
    private global::ChromeosUpdateEngine.ImageInfo oldImageInfo_;
    /// <summary>
    /// old_image_info will only be present for delta images.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.ImageInfo OldImageInfo {
      get { return oldImageInfo_; }
      set {
        oldImageInfo_ = value;
      }
    }

    /// <summary>Field number for the "new_image_info" field.</summary>
    public const int NewImageInfoFieldNumber = 11;
    private global::ChromeosUpdateEngine.ImageInfo newImageInfo_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.ImageInfo NewImageInfo {
      get { return newImageInfo_; }
      set {
        newImageInfo_ = value;
      }
    }

    /// <summary>Field number for the "minor_version" field.</summary>
    public const int MinorVersionFieldNumber = 12;
    private readonly static uint MinorVersionDefaultValue = 0;

    private uint minorVersion_;
    /// <summary>
    /// The minor version, also referred as "delta version", of the payload.
    /// Minor version 0 is full payload, everything else is delta payload.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MinorVersion {
      get { if ((_hasBits0 & 8) != 0) { return minorVersion_; } else { return MinorVersionDefaultValue; } }
      set {
        _hasBits0 |= 8;
        minorVersion_ = value;
      }
    }
    /// <summary>Gets whether the "minor_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMinorVersion {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "minor_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMinorVersion() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "partitions" field.</summary>
    public const int PartitionsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::ChromeosUpdateEngine.PartitionUpdate> _repeated_partitions_codec
        = pb::FieldCodec.ForMessage(106, global::ChromeosUpdateEngine.PartitionUpdate.Parser);
    private readonly pbc::RepeatedField<global::ChromeosUpdateEngine.PartitionUpdate> partitions_ = new pbc::RepeatedField<global::ChromeosUpdateEngine.PartitionUpdate>();
    /// <summary>
    /// Only present in major version >= 2. List of partitions that will be
    /// updated, in the order they will be updated. This field replaces the
    /// |install_operations|, |kernel_install_operations| and the
    /// |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
    /// array can have more than two partitions if needed, and they are identified
    /// by the partition name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::ChromeosUpdateEngine.PartitionUpdate> Partitions {
      get { return partitions_; }
    }

    /// <summary>Field number for the "max_timestamp" field.</summary>
    public const int MaxTimestampFieldNumber = 14;
    private readonly static long MaxTimestampDefaultValue = 0L;

    private long maxTimestamp_;
    /// <summary>
    /// The maximum timestamp of the OS allowed to apply this payload.
    /// Can be used to prevent downgrading the OS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MaxTimestamp {
      get { if ((_hasBits0 & 16) != 0) { return maxTimestamp_; } else { return MaxTimestampDefaultValue; } }
      set {
        _hasBits0 |= 16;
        maxTimestamp_ = value;
      }
    }
    /// <summary>Gets whether the "max_timestamp" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMaxTimestamp {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "max_timestamp" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMaxTimestamp() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "dynamic_partition_metadata" field.</summary>
    public const int DynamicPartitionMetadataFieldNumber = 15;
    private global::ChromeosUpdateEngine.DynamicPartitionMetadata dynamicPartitionMetadata_;
    /// <summary>
    /// Metadata related to all dynamic partitions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::ChromeosUpdateEngine.DynamicPartitionMetadata DynamicPartitionMetadata {
      get { return dynamicPartitionMetadata_; }
      set {
        dynamicPartitionMetadata_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeltaArchiveManifest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeltaArchiveManifest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!installOperations_.Equals(other.installOperations_)) return false;
      if(!kernelInstallOperations_.Equals(other.kernelInstallOperations_)) return false;
      if (BlockSize != other.BlockSize) return false;
      if (SignaturesOffset != other.SignaturesOffset) return false;
      if (SignaturesSize != other.SignaturesSize) return false;
      if (!object.Equals(OldKernelInfo, other.OldKernelInfo)) return false;
      if (!object.Equals(NewKernelInfo, other.NewKernelInfo)) return false;
      if (!object.Equals(OldRootfsInfo, other.OldRootfsInfo)) return false;
      if (!object.Equals(NewRootfsInfo, other.NewRootfsInfo)) return false;
      if (!object.Equals(OldImageInfo, other.OldImageInfo)) return false;
      if (!object.Equals(NewImageInfo, other.NewImageInfo)) return false;
      if (MinorVersion != other.MinorVersion) return false;
      if(!partitions_.Equals(other.partitions_)) return false;
      if (MaxTimestamp != other.MaxTimestamp) return false;
      if (!object.Equals(DynamicPartitionMetadata, other.DynamicPartitionMetadata)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= installOperations_.GetHashCode();
      hash ^= kernelInstallOperations_.GetHashCode();
      if (HasBlockSize) hash ^= BlockSize.GetHashCode();
      if (HasSignaturesOffset) hash ^= SignaturesOffset.GetHashCode();
      if (HasSignaturesSize) hash ^= SignaturesSize.GetHashCode();
      if (oldKernelInfo_ != null) hash ^= OldKernelInfo.GetHashCode();
      if (newKernelInfo_ != null) hash ^= NewKernelInfo.GetHashCode();
      if (oldRootfsInfo_ != null) hash ^= OldRootfsInfo.GetHashCode();
      if (newRootfsInfo_ != null) hash ^= NewRootfsInfo.GetHashCode();
      if (oldImageInfo_ != null) hash ^= OldImageInfo.GetHashCode();
      if (newImageInfo_ != null) hash ^= NewImageInfo.GetHashCode();
      if (HasMinorVersion) hash ^= MinorVersion.GetHashCode();
      hash ^= partitions_.GetHashCode();
      if (HasMaxTimestamp) hash ^= MaxTimestamp.GetHashCode();
      if (dynamicPartitionMetadata_ != null) hash ^= DynamicPartitionMetadata.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      installOperations_.WriteTo(output, _repeated_installOperations_codec);
      kernelInstallOperations_.WriteTo(output, _repeated_kernelInstallOperations_codec);
      if (HasBlockSize) {
        output.WriteRawTag(24);
        output.WriteUInt32(BlockSize);
      }
      if (HasSignaturesOffset) {
        output.WriteRawTag(32);
        output.WriteUInt64(SignaturesOffset);
      }
      if (HasSignaturesSize) {
        output.WriteRawTag(40);
        output.WriteUInt64(SignaturesSize);
      }
      if (oldKernelInfo_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(OldKernelInfo);
      }
      if (newKernelInfo_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NewKernelInfo);
      }
      if (oldRootfsInfo_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(OldRootfsInfo);
      }
      if (newRootfsInfo_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(NewRootfsInfo);
      }
      if (oldImageInfo_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(OldImageInfo);
      }
      if (newImageInfo_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(NewImageInfo);
      }
      if (HasMinorVersion) {
        output.WriteRawTag(96);
        output.WriteUInt32(MinorVersion);
      }
      partitions_.WriteTo(output, _repeated_partitions_codec);
      if (HasMaxTimestamp) {
        output.WriteRawTag(112);
        output.WriteInt64(MaxTimestamp);
      }
      if (dynamicPartitionMetadata_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(DynamicPartitionMetadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += installOperations_.CalculateSize(_repeated_installOperations_codec);
      size += kernelInstallOperations_.CalculateSize(_repeated_kernelInstallOperations_codec);
      if (HasBlockSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BlockSize);
      }
      if (HasSignaturesOffset) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SignaturesOffset);
      }
      if (HasSignaturesSize) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SignaturesSize);
      }
      if (oldKernelInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OldKernelInfo);
      }
      if (newKernelInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewKernelInfo);
      }
      if (oldRootfsInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OldRootfsInfo);
      }
      if (newRootfsInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewRootfsInfo);
      }
      if (oldImageInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OldImageInfo);
      }
      if (newImageInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewImageInfo);
      }
      if (HasMinorVersion) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinorVersion);
      }
      size += partitions_.CalculateSize(_repeated_partitions_codec);
      if (HasMaxTimestamp) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxTimestamp);
      }
      if (dynamicPartitionMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DynamicPartitionMetadata);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeltaArchiveManifest other) {
      if (other == null) {
        return;
      }
      installOperations_.Add(other.installOperations_);
      kernelInstallOperations_.Add(other.kernelInstallOperations_);
      if (other.HasBlockSize) {
        BlockSize = other.BlockSize;
      }
      if (other.HasSignaturesOffset) {
        SignaturesOffset = other.SignaturesOffset;
      }
      if (other.HasSignaturesSize) {
        SignaturesSize = other.SignaturesSize;
      }
      if (other.oldKernelInfo_ != null) {
        if (oldKernelInfo_ == null) {
          OldKernelInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        OldKernelInfo.MergeFrom(other.OldKernelInfo);
      }
      if (other.newKernelInfo_ != null) {
        if (newKernelInfo_ == null) {
          NewKernelInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        NewKernelInfo.MergeFrom(other.NewKernelInfo);
      }
      if (other.oldRootfsInfo_ != null) {
        if (oldRootfsInfo_ == null) {
          OldRootfsInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        OldRootfsInfo.MergeFrom(other.OldRootfsInfo);
      }
      if (other.newRootfsInfo_ != null) {
        if (newRootfsInfo_ == null) {
          NewRootfsInfo = new global::ChromeosUpdateEngine.PartitionInfo();
        }
        NewRootfsInfo.MergeFrom(other.NewRootfsInfo);
      }
      if (other.oldImageInfo_ != null) {
        if (oldImageInfo_ == null) {
          OldImageInfo = new global::ChromeosUpdateEngine.ImageInfo();
        }
        OldImageInfo.MergeFrom(other.OldImageInfo);
      }
      if (other.newImageInfo_ != null) {
        if (newImageInfo_ == null) {
          NewImageInfo = new global::ChromeosUpdateEngine.ImageInfo();
        }
        NewImageInfo.MergeFrom(other.NewImageInfo);
      }
      if (other.HasMinorVersion) {
        MinorVersion = other.MinorVersion;
      }
      partitions_.Add(other.partitions_);
      if (other.HasMaxTimestamp) {
        MaxTimestamp = other.MaxTimestamp;
      }
      if (other.dynamicPartitionMetadata_ != null) {
        if (dynamicPartitionMetadata_ == null) {
          DynamicPartitionMetadata = new global::ChromeosUpdateEngine.DynamicPartitionMetadata();
        }
        DynamicPartitionMetadata.MergeFrom(other.DynamicPartitionMetadata);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            installOperations_.AddEntriesFrom(input, _repeated_installOperations_codec);
            break;
          }
          case 18: {
            kernelInstallOperations_.AddEntriesFrom(input, _repeated_kernelInstallOperations_codec);
            break;
          }
          case 24: {
            BlockSize = input.ReadUInt32();
            break;
          }
          case 32: {
            SignaturesOffset = input.ReadUInt64();
            break;
          }
          case 40: {
            SignaturesSize = input.ReadUInt64();
            break;
          }
          case 50: {
            if (oldKernelInfo_ == null) {
              OldKernelInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(OldKernelInfo);
            break;
          }
          case 58: {
            if (newKernelInfo_ == null) {
              NewKernelInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(NewKernelInfo);
            break;
          }
          case 66: {
            if (oldRootfsInfo_ == null) {
              OldRootfsInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(OldRootfsInfo);
            break;
          }
          case 74: {
            if (newRootfsInfo_ == null) {
              NewRootfsInfo = new global::ChromeosUpdateEngine.PartitionInfo();
            }
            input.ReadMessage(NewRootfsInfo);
            break;
          }
          case 82: {
            if (oldImageInfo_ == null) {
              OldImageInfo = new global::ChromeosUpdateEngine.ImageInfo();
            }
            input.ReadMessage(OldImageInfo);
            break;
          }
          case 90: {
            if (newImageInfo_ == null) {
              NewImageInfo = new global::ChromeosUpdateEngine.ImageInfo();
            }
            input.ReadMessage(NewImageInfo);
            break;
          }
          case 96: {
            MinorVersion = input.ReadUInt32();
            break;
          }
          case 106: {
            partitions_.AddEntriesFrom(input, _repeated_partitions_codec);
            break;
          }
          case 112: {
            MaxTimestamp = input.ReadInt64();
            break;
          }
          case 122: {
            if (dynamicPartitionMetadata_ == null) {
              DynamicPartitionMetadata = new global::ChromeosUpdateEngine.DynamicPartitionMetadata();
            }
            input.ReadMessage(DynamicPartitionMetadata);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
